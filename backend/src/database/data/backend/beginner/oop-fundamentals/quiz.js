// ============================================================================
// OOP Fundamentals — Quiz Questions
// ============================================================================

const quiz = {
  'classes-objects-encapsulation': [
    {
      question_text: "What is encapsulation in OOP?",
      question_type: "multiple_choice",
      options: ["Inheriting from a parent class", "Bundling data and methods while hiding internal state", "Creating multiple instances of a class", "Converting objects to JSON"],
      correct_answer: "Bundling data and methods while hiding internal state",
      explanation: "Encapsulation is the practice of bundling data (properties) and the methods that operate on that data into a single unit (class), while restricting direct access to some of the object's internals through access modifiers.",
      difficulty: "easy",
      order_index: 1,
    },
    {
      question_text: "How do you declare a private field in modern JavaScript classes?",
      question_type: "multiple_choice",
      options: ["Using the private keyword", "Prefixing with # (e.g., #balance)", "Prefixing with _ (e.g., _balance)", "Using Object.freeze()"],
      correct_answer: "Prefixing with # (e.g., #balance)",
      explanation: "JavaScript uses the # prefix for truly private class fields (e.g., #balance). The _ prefix is merely a naming convention with no runtime enforcement. The 'private' keyword is used in TypeScript and other languages, not vanilla JavaScript.",
      difficulty: "easy",
      order_index: 2,
    },
    {
      question_text: "What are the three fundamental aspects of every object?",
      question_type: "multiple_choice",
      options: ["Name, type, value", "Identity, state, behavior", "Class, instance, method", "Public, private, protected"],
      correct_answer: "Identity, state, behavior",
      explanation: "Every object has: Identity (a unique reference/memory address that distinguishes it from others), State (the current values of its properties), and Behavior (the methods it can execute).",
      difficulty: "medium",
      order_index: 3,
    },
    {
      question_text: "What does the 'this' keyword refer to inside a class method?",
      question_type: "multiple_choice",
      options: ["The class definition itself", "The global window object", "The current object instance calling the method", "The parent class"],
      correct_answer: "The current object instance calling the method",
      explanation: "Inside a class method, 'this' refers to the specific object instance that called the method. It allows the method to access and modify that particular object's properties.",
      difficulty: "easy",
      order_index: 4,
    },
    {
      question_text: "What is the difference between a static method and an instance method?",
      question_type: "multiple_choice",
      options: ["Static methods are faster", "Static methods belong to the class itself, instance methods belong to each object", "Static methods cannot return values", "There is no difference"],
      correct_answer: "Static methods belong to the class itself, instance methods belong to each object",
      explanation: "Static methods are called on the class (e.g., Math.random(), User.fromJSON()) and don't have access to 'this' instance. Instance methods are called on individual objects (e.g., user.getName()) and operate on that specific instance's data.",
      difficulty: "medium",
      order_index: 5,
    },
  ],
  'inheritance-polymorphism': [
    {
      question_text: "What does the super() call do in a subclass constructor?",
      question_type: "multiple_choice",
      options: ["Creates a new instance of the subclass", "Calls the parent class constructor", "Makes the class abstract", "Overrides the parent method"],
      correct_answer: "Calls the parent class constructor",
      explanation: "super() invokes the parent class constructor to initialize the inherited properties. It is REQUIRED in a subclass constructor before you can use 'this', because the parent's initialization logic must run first.",
      difficulty: "easy",
      order_index: 1,
    },
    {
      question_text: "What is polymorphism?",
      question_type: "multiple_choice",
      options: ["Having multiple constructors", "Objects of different types responding to the same interface", "A class inheriting from multiple parents", "Converting between data types"],
      correct_answer: "Objects of different types responding to the same interface",
      explanation: "Polymorphism ('many forms') means different classes can be used interchangeably through a shared interface. For example, both Circle and Rectangle implement area(), but each calculates it differently. The calling code doesn't need to know the specific type.",
      difficulty: "easy",
      order_index: 2,
    },
    {
      question_text: "What is the prototype chain in JavaScript?",
      question_type: "multiple_choice",
      options: ["A design pattern for creating objects", "A linked chain of objects where each has a reference to its prototype, ending at null", "A way to chain method calls", "A list of all classes in the program"],
      correct_answer: "A linked chain of objects where each has a reference to its prototype, ending at null",
      explanation: "Every JavaScript object has an internal [[Prototype]] link. When you access a property, JS walks up the chain (object → prototype → prototype's prototype → ... → null) until it finds it or reaches the end. Classes are syntactic sugar over this mechanism.",
      difficulty: "medium",
      order_index: 3,
    },
    {
      question_text: "Why is 'composition over inheritance' recommended?",
      question_type: "multiple_choice",
      options: ["Composition is always faster", "Composition avoids tight coupling and allows flexible behavior mixing", "Inheritance is deprecated in modern JavaScript", "Composition uses less memory"],
      correct_answer: "Composition avoids tight coupling and allows flexible behavior mixing",
      explanation: "Inheritance creates tight coupling — a child depends on its parent's implementation. Composition assembles behavior from independent, reusable pieces, making code more flexible. You can mix/match behaviors and even swap them at runtime.",
      difficulty: "medium",
      order_index: 4,
    },
    {
      question_text: "What does the instanceof operator check?",
      question_type: "multiple_choice",
      options: ["If two objects have the same properties", "If an object is an instance of a specific class or its ancestors", "If a class is abstract", "If a method exists on an object"],
      correct_answer: "If an object is an instance of a specific class or its ancestors",
      explanation: "The instanceof operator checks the prototype chain to determine if an object was created from a specific class or any class in its inheritance hierarchy. For example, if Dog extends Animal, then (new Dog()) instanceof Animal returns true.",
      difficulty: "easy",
      order_index: 5,
    },
  ],
  'abstraction-solid-intro': [
    {
      question_text: "What does the Single Responsibility Principle state?",
      question_type: "multiple_choice",
      options: ["A class should do everything related to one entity", "A class should have only one reason to change", "A class should be a singleton", "Methods should have one parameter"],
      correct_answer: "A class should have only one reason to change",
      explanation: "SRP means each class should have exactly one responsibility or 'reason to change'. If a User class handles database logic, email, and reports, changes to any of those areas would require modifying User — violating SRP. Separate them into UserRepository, EmailService, and UserReport.",
      difficulty: "easy",
      order_index: 1,
    },
    {
      question_text: "What is Dependency Inversion about?",
      question_type: "multiple_choice",
      options: ["Inverting the call stack", "High-level modules depending on abstractions, not concrete implementations", "Avoiding all dependencies", "Using only static methods"],
      correct_answer: "High-level modules depending on abstractions, not concrete implementations",
      explanation: "DIP states that high-level modules (business logic) should not depend on low-level modules (database, email). Both should depend on abstractions. Instead of OrderService creating 'new PostgresDB()', it receives a Database interface via constructor injection.",
      difficulty: "medium",
      order_index: 2,
    },
    {
      question_text: "What is the difference between abstraction and encapsulation?",
      question_type: "multiple_choice",
      options: ["They are the same thing", "Abstraction hides complexity (what vs how), encapsulation hides data (access control)", "Abstraction is for interfaces, encapsulation is for classes", "Abstraction is runtime, encapsulation is compile-time"],
      correct_answer: "Abstraction hides complexity (what vs how), encapsulation hides data (access control)",
      explanation: "Abstraction operates at the design level — it hides HOW something works and exposes WHAT it does (e.g., a Database interface with query()). Encapsulation operates at the code level — it hides internal DATA using access modifiers (e.g., #balance private field with getBalance()).",
      difficulty: "medium",
      order_index: 3,
    },
    {
      question_text: "What does the Liskov Substitution Principle (LSP) require?",
      question_type: "multiple_choice",
      options: ["All classes must have a substitute", "Subclasses must be usable wherever their parent class is expected without breaking the program", "Only one class can extend another", "Substitution is optional in OOP"],
      correct_answer: "Subclasses must be usable wherever their parent class is expected without breaking the program",
      explanation: "LSP says that if function X works with a parent type, it should also work correctly with any subtype. The classic violation is Square extending Rectangle — calling setWidth() on a Square unexpectedly changes the height too, breaking code that expects independent dimensions.",
      difficulty: "medium",
      order_index: 4,
    },
    {
      question_text: "What does the Open-Closed Principle mean in practice?",
      question_type: "multiple_choice",
      options: ["Files should be opened then closed", "Code should be open for extension but closed for modification", "Classes should be open source", "Methods should be closed to external access"],
      correct_answer: "Code should be open for extension but closed for modification",
      explanation: "OCP means you should be able to add new behavior without changing existing code. For example, using the Strategy Pattern: adding a new ShippingStrategy subclass extends the system without modifying the Order class. This prevents introducing bugs in existing, tested code.",
      difficulty: "medium",
      order_index: 5,
    },
  ],
};

export default quiz;
